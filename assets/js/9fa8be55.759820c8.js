"use strict";(self.webpackChunkwiki=self.webpackChunkwiki||[]).push([[284],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>k});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function p(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),m=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},d=function(e){var t=m(e.components);return n.createElement(o.Provider,{value:t},e.children)},s={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},N=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,d=p(e,["components","mdxType","originalType","parentName"]),N=m(a),k=r,u=N["".concat(o,".").concat(k)]||N[k]||s[k]||i;return a?n.createElement(u,l(l({ref:t},d),{},{components:a})):n.createElement(u,l({ref:t},d))}));function k(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=N;var p={};for(var o in t)hasOwnProperty.call(t,o)&&(p[o]=t[o]);p.originalType=e,p.mdxType="string"==typeof e?e:r,l[1]=p;for(var m=2;m<i;m++)l[m]=a[m];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}N.displayName="MDXCreateElement"},5054:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>s,frontMatter:()=>i,metadata:()=>p,toc:()=>m});var n=a(7462),r=(a(7294),a(3905));a(2969);const i={id:"three-address-code",sidebar_position:1},l="Three-Address Code",p={unversionedId:"intermediate-code/three-address-code",id:"intermediate-code/three-address-code",title:"Three-Address Code",description:"Three-Address Code (TAC, \u4e09\u5730\u5740\u4ee3\u7801) is the form of high-level assembly where each operation has at most three operands. The generic form of TAC is X = Y op Z, where X, Y, Z can be varibles, constants or compiler-generated temporaries holding intermediate values.",source:"@site/comp/intermediate-code/01_three-address-code.md",sourceDirName:"intermediate-code",slug:"/intermediate-code/three-address-code",permalink:"/comp/intermediate-code/three-address-code",draft:!1,editUrl:"https://github.com/lixk28/wiki/tree/main/comp/intermediate-code/01_three-address-code.md",tags:[],version:"current",lastUpdatedBy:"snow",lastUpdatedAt:1655183782,formattedLastUpdatedAt:"Jun 14, 2022",sidebarPosition:1,frontMatter:{id:"three-address-code",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"intermediate-code",permalink:"/comp/intermediate-code/intermediate-code"}},o={},m=[{value:"Three-Address Code Instructions",id:"three-address-code-instructions",level:2},{value:"Quadruples",id:"quadruples",level:2},{value:"Triples",id:"triples",level:2},{value:"Static Single-Assignment Form",id:"static-single-assignment-form",level:2}],d={toc:m};function s(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"three-address-code"},"Three-Address Code"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Three-Address Code (TAC, \u4e09\u5730\u5740\u4ee3\u7801)")," is the form of high-level assembly where each operation has at most ",(0,r.kt)("u",null,"three")," operands. The generic form of TAC is ",(0,r.kt)("inlineCode",{parentName:"p"},"X = Y op Z"),", where ",(0,r.kt)("inlineCode",{parentName:"p"},"X"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Y"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Z")," can be varibles, constants or compiler-generated temporaries holding intermediate values."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"TAC is desirable for target-code generation:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Multi-operator arithmetic expressions are converted to multiple instructions."),(0,r.kt)("li",{parentName:"ul"},"Nested control flow statements are converted to jumps."))),(0,r.kt)("li",{parentName:"ul"},"TAC is desirable for machine-independent optimization:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The operations are generic."),(0,r.kt)("li",{parentName:"ul"},"Function calls represented as generic call nodes."),(0,r.kt)("li",{parentName:"ul"},"Use symbolic names rather than register names."))),(0,r.kt)("li",{parentName:"ul"},"TAC is easy to be rearranged:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The use of compiler-generated temporaries for intermediate values.")))),(0,r.kt)("h2",{id:"three-address-code-instructions"},"Three-Address Code Instructions"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Binary assignment instruction"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tac"},"x = y op z\n")),(0,r.kt)("p",{parentName:"li"},"where ",(0,r.kt)("inlineCode",{parentName:"p"},"op")," is a binary arithmetic or logical operation, ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"z")," are addresses.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Unary assignment instruction"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tac"},"x = op y\n")),(0,r.kt)("p",{parentName:"li"},"where ",(0,r.kt)("inlineCode",{parentName:"p"},"op")," is a unary operation.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Copy instruction"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tac"},"x = y\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"x")," is assigned the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Unconditional jump"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tac"},"goto L\n")),(0,r.kt)("p",{parentName:"li"},"where ",(0,r.kt)("inlineCode",{parentName:"p"},"L")," is a label.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Conditional jump"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tac"},"if x goto L\nif (x relop y) goto L\n")),(0,r.kt)("p",{parentName:"li"},"where ",(0,r.kt)("inlineCode",{parentName:"p"},"relop")," is a relational operator.\nExecute the instruction with label ",(0,r.kt)("inlineCode",{parentName:"p"},"L")," next if the expression is true, otherwise the following instruction in sequence is executed next.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Procedural call"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tac"},"param a1\nparam a2\n...\nparam an\ncall proc, n\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"param ai")," for parameters, ",(0,r.kt)("inlineCode",{parentName:"p"},"proc")," stands for the procedure being called, ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," indicates the number of parameters.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Procedural call return"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tac"},"return x\n")),(0,r.kt)("p",{parentName:"li"},"where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," is the return value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Indexed assignment"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tac"},"x = y[i]\n")),(0,r.kt)("p",{parentName:"li"},"Set ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," to the value in the location ",(0,r.kt)("inlineCode",{parentName:"p"},"i")," memory units beyond location ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tac"},"y = x[i]\n")),(0,r.kt)("p",{parentName:"li"},"Set the contents of location ",(0,r.kt)("inlineCode",{parentName:"p"},"i")," units beyond ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," to the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Address and pointer operation"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tac"},"x = &y\n")),(0,r.kt)("p",{parentName:"li"},"A pointer ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," is set to the address of ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tac"},"x = *y\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"x")," is set to the value of location pointed to by pointer ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),"."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tac"},"*x = y\n")),(0,r.kt)("p",{parentName:"li"},"The content pointed to by pointer ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," is assigned ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"."))),(0,r.kt)("admonition",{title:"A TAC Example for Atrithmetic Expressions",type:"note"},(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-c"},"a + a * (b - c) + (b - c) * d\n")),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-tac"},"t1 = b - c\nt2 = a * t1\nt3 = a + t2\nt4 = t1 * d\nt5 = t3 + t4\n"))),(0,r.kt)("admonition",{title:"A TAC Example for Control Flow Statements",type:"note"},(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-c"},"i = 1;\ndo {\n  a[i] = x * 5;\n  i++;\n} while (i <= 10);\n")),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-tac"},"    i = 1\nL:  t1 = x * 5\n    a[i] = t1\n    i = i + 1\n    if i <= 10 goto L\n")),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("inlineCode",{parentName:"p"},"a[i] = x * 5")," can be translated more detailedly."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-tac"},"    i = 1\nL:  t1 = x * 5\n    t2 = &a\n    t3 = sizeof(int)\n    t4 = t3 * i\n    t5 = t2 + t4\n    *t5 = t1\n    i = i + 1\n    if i <= 10 goto L\n"))),(0,r.kt)("h2",{id:"quadruples"},"Quadruples"),(0,r.kt)("p",null,"A ",(0,r.kt)("strong",{parentName:"p"},"Quadruple (\u56db\u5143\u5f0f)")," has four fileds:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-quad"},"(op, arg1, arg2, result)\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"op")," contains an internal code for the operator."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"arg1"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"arg2")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"result")," are optional, depending on the ",(0,r.kt)("inlineCode",{parentName:"li"},"op"),".")),(0,r.kt)("p",null,"Three-address code represented in quadruple:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Binary assignment instruction"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tac"},"x = y op z\n")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-quad"},"(op, y, z, x)\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Unary assignment instruction"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tac"},"x = op y\n")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-quad"},"(op, y, nil, x)\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"arg2")," is not used for unary assignments instruction (",(0,r.kt)("inlineCode",{parentName:"p"},"nil")," means it's empty).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Copy instruction"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tac"},"x = y\n")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-quad"},"(=, y, nil, x)\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"op")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"=")," for copy instruction, while for most operations, the assignment operator is implied.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Unconditional jump"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tac"},"goto L\n")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-quad"},"(goto, nil, nil, L)\n")),(0,r.kt)("p",{parentName:"li"},"The target label ",(0,r.kt)("inlineCode",{parentName:"p"},"L")," is put in ",(0,r.kt)("inlineCode",{parentName:"p"},"result")," field.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Conditional jump"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tac"},"")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-quad"},""))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Procedural call"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tac"},"param ai\n")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-quad"},"(param, ai, nil, nil)\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"param")," use neither ",(0,r.kt)("inlineCode",{parentName:"p"},"arg2")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"result"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Procedural call return"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tac"},"return x\n")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-quad"},"(return, x, nil, nil)\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"return")," use neither ",(0,r.kt)("inlineCode",{parentName:"p"},"arg2")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"result"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Indexed assignment")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Address and pointer operation"))),(0,r.kt)("admonition",{title:"Quadruple Representation for Arithmetic Expressions",type:"note"},(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-c"},"a = b * -c + b * -c\n")),(0,r.kt)("table",{parentName:"admonition"},(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"position"),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"op")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"arg1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"arg2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"result")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"(0)"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"-")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"c")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"t1"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"(1)"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"*")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"b")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"t1")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"t2"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"(2)"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"-")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"c")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"t3"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"(3)"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"*")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"b")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"t3")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"t4"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"(4)"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"+")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"t2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"t4")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"t5"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"(5)"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"=")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"t5")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"a")))))),(0,r.kt)("h2",{id:"triples"},"Triples"),(0,r.kt)("p",null,"A ",(0,r.kt)("strong",{parentName:"p"},"Triple (\u4e09\u5143\u5f0f)")," has three fields (quadruple without the ",(0,r.kt)("inlineCode",{parentName:"p"},"result")," field):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tri"},"(op, arg1, arg2)\n")),(0,r.kt)("p",null,"Triples refer to the result of an operation ",(0,r.kt)("inlineCode",{parentName:"p"},"x op y")," by its position, rather than by an explicit temporary name."),(0,r.kt)("admonition",{title:"Triple Representation for Arithmetic Expressions",type:"note"},(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-c"},"a = b * -c + b * -c\n")),(0,r.kt)("table",{parentName:"admonition"},(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"position"),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"op")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"arg1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"arg2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"(0)"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"-")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"c")),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"(1)"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"*")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"b")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(0)"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"(2)"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"-")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"c")),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"(3)"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"*")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"b")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(2)"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"(4)"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"+")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(1)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(3)"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"(5)"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"=")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"a")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(4)")))))),(0,r.kt)("h2",{id:"static-single-assignment-form"},"Static Single-Assignment Form"))}s.isMDXComponent=!0},2969:(e,t,a)=>{a.d(t,{Z:()=>r});var n=a(7294);function r(e){let{children:t,color:a}=e;return n.createElement("span",{style:{color:a}},t)}}}]);